## Computer Science

- OS

  - Semaphore VS Mutex

    ```markdown
    1. Semaphore는 공유된 자원을 다른 프로세스가 사용 못하게 막는 것이다.
    2. Mutex는 공유된 자원을 다른 스레드가 사용 못하게 막는 것이다.
    3. 가장 큰 차이점은 관리하는 동기화 대상의 수가 다르다 Semaphore는 동기화 대상이 하나 이상일때 사용하며, Mutex는 동기화 대상이 오직 하나일때 사용한다.
    ```

  - exec() VS fork()

    ```markdown
    1. exec()는 새로운 프로세르를 위한 메모리를 할당하지 않고, exec()에 의해 호출된 프로세스만 남게된다.
    2. fork()는 호출시 새로운 프로세스를 위한 메모리를 할당하고, 각자 실행된다.
    ```

  - 선점 vs 비선점 and 정책들과 알고리즘 종류

    ```markdown
    1. 선점 :  CPU를 할당 받아 작업을 수행 중이라도 다른 프로세스에 의해 작업을 중지하고 CPU를 강제로 할당 받을 수    있다.
       1) 종류 : RR(Round Robin), SRT(Shortest Remaining Time), MQ(Multi-Level Queue)
    3. 비선점 : CPU를 할당 받아 작업이 종료 될때 까지 다른 프로세스에 의해 CPU자원을 빼앗기지 않는다.
       1) 종류 : FCFS(First Come First Served Scheduling), SJF(Shortest Job First Scheduling),    HRRN(Highest Response Ratio Next Scheduling)
    ```

  - LRU VS R.R 시간계산하기

    ```markdown
    1.
    ```

  - Deadlock 설명과 회피방법 4가지

    ```markdown
    1. 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, ‘교착 상태’라고도 하며 시스템적으로 한정된 자원을 여   러 곳에서 사용하려고 할 때 발생합니다.
    
    2. 발생조건
       1) 상호 배제 (Mutual exclusion) : 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.
       2) 점유 대기 (Hold and wait) : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는        자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.
       3) 비선점 (No preemption) : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.
       4) 순환 대기 (Circular wait) : 프로세스의 집합 {P0, P1, ,…Pn}에서 P0는 P1이 점유한 자원을 대기하고       P1은 P2가 점유한 자원을 대기하고 P2…Pn-1은 Pn이 점유한 자원을 대기하며 Pn은 P0가 점유한 자원을 요구해야       한다.
       
    3. 회피방법은 발생조건중 한 가지라도 피하면 된다.
    ```

  - multi thread VS multi process

    ```markdown
    1. 멀티 스레드 : 스택 영역을 제외한 모든 자원을 공유, 하나의 프로세스가 다수 개의 작업을 각각 스레드를 이용하여 동시에 작동 시킬 수 있다.
    2. 멀티 프로세스 : 환경변수와 프로세스 핸들 테이블이 상속 가능할 뿐 결국 독립적인 관계이다. fork() 과정을 생각하면 된다. 또한 프로세스간에 통신을 하기위해서는 IPC를 활용해야한다. 크롬의 탭 으로 생각하면 될듯.
    ```

  - 메모리 구조에대해 설명해주세요

  - ```markdown
    1. code 영역
       - 실행할 프로그램의 코드가 저장되는 텍스트 영역입니다. CPU는 코드영역에서 저장된 명령어를 하나씩 가져가서 처리합         니다.
       
    2. data 영역
       - 전역변수와 정적변수가 이해 해당됩니다. 프로그램의 시작과 함께 할당되며 프로그램이 종료되면 소멸됩니다.
       
    3. heap 영역
       - 힙 영역은 사용자가 직접 관리할 수 있는 메모리 영역입니다. 힙 영역은 사용자에 의해 메모리공간이 동적으로 할당되         고 해제됩니다.
       
    4. stack 영역
       - 스택영역은 함수의 호출과 관계되는 지역변수와 매개변수가 저장되는 영역입니다. 함수의 호출과 함께 할당되며, 함수의       호출이 종료될때 해제됩니다.
    ```

  - OS는 더 추가해야할 사항.

- JAVA

  - JVM on Java 

    ```markdown
    1. 컴파일러가 class 파일 생성 
    2. class loader를 통해 bytecode로 변환
    3. JVM이 bytecode를 할당된 메모리에서 작동
    ```

  - GC 는 무엇이며 줄이는 방법

    ```markdown
    1. GC : 사용하지 않은 메모리 관리
    2. 단점 : 오버헤드가 크다, 언제 작동할지 모른다.
    3. 줄이는 법 : static 변수를 줄인다. 싱글톤을 활용한다.
    ```

  - Overriding VS Overloading

    ```markdown
    1. Overriding : 부모로부터 상속받은 객체를 사용하는것, 하위 메소드에서 재정의 해서 사용 가능.
    2. Overloading : 같은 이름의 메소드 이나 입력받는 파라미터에 따라서 다른 메소드로 취급받는 것.
    ```

  - class VS object VS instance

    ```markdown
    1. Object : 상태나 행동 등을 가지지만 SW의 입장에서는 컨셉에 불과하다.
    2. Class : 컨셉에 불과한 객체를 구현하는 설계도.
    3. Instance : 설계도를 바탕으로 객체를 구현, 구현된 instance는 메모리에 할당된다.
    ```

  - connection pool

    ```markdown
    1. 커넥션을 미리 만들어 저장해 놓은 장소, 미리 만들어 놓는 이유는 요청이 한꺼번에 몰릴 경우 시간이 오래 걸리기때문
    ```

  - 객체지향 프로그래밍의 특징

  - ```markdown
    1. 캡슐화
    2. 상속
    3. 추상화
    4. 다형성
    ```

  - Java의 Thread

  - ```markdown
    1. Thread 상속 받기
       1) 항상 run() 메서드를 override해야한다.
       
    2. Runnable 인터페이스 구현
       1) Thread 상속 받을 경우 다른 클래스를 상속 받을 수 없다. 하지만 Runnable로 인터페이스를 구현하면 다른 클래      스를 상속 받을 수 있다.   
    ```

  - Try-Catch-Finally

  - ```markdown
    - try 문에 return 이 있더라도 finally 구문은 실행된다.
    ```

  - 상속 관점에서 생성자를 private로 선언하면 어떤 효과가 있나?

  - ```markdown
    - 자기 자신만 부모 클래스에 접근 할 수 있다.
    ```

  - Collection 에서 제네릭을 사용하는 이유

  - ```markdown
    - 컬렉션 클래스에서 제네릭을 사용하면 컴파일러는 특정 타입만 포함 될 수 있도록 컬렉션을 제한합니다. 
    - 컬렉션 클래스에 저장하는 인스턴스 타입을 제한하여 런타임에 발생할 수 있는 잠재적인 모든 예외를 컴파일타임에 잡아낼 수 있도록 도와줍니다.
    ```

  - wrapper class 에 대해 설명

  - ```markdown
    - 기본 자료형으로 표현된 데이터를 참조 자료형으로 만들어야 할 경우 래퍼 클래스를 사용합니다. 
       보통 특정 메소드에서 참조 자료형을 인자로 받거나, 기본 자료형이 아닌 객체 자료형으로 저장해야할 경우, 객체간 비교    가 필요할 경우에 사용합니다.
    ```

  - interface에 대해 설명

  - ```markdown
    - 인터페이스는 모든 메서드가 구현부가 없는 추상메서드로 이루어져 있습니다.
    ```

  - Thread pool 에 대해 설명

  - ```markdown
    - 주로 멀티 스레드에서 사용, 스레드를 미리 만들어 놓고 작업요청이 있을 때마다 스레드를 할당
    ```

  - 

- Web

  - Rest API 와 Restful API

    ```markdown
    1. Restful API 는 일반적으로 REST라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어이다. REST를     REST답게 쓰기 위한 방법으로, 누군가가 공식적으로 발표한 것이 아니다.
    2. Restful 하지 못한 경우
       1) CRUD 기능을 모두 Post로 처리하는 API
       2) route에 resource, id 외의 정보가 들어가는 경우(/students/updateName)
       
    3. Rest API는 HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.
    
    ```

  - Vuex 설명

    ```markdown
    1. Vue에서 데이터의 상태변화를 관리하는 임시 저장소
    ```

  - 동기화 vs 비동기화

    ```markdown
    1. 동기화
       1) Request를 보낸 뒤에 Response가 오지 않더라도 다음 진행단계를 수행한다.
    2. 비동기화
       1) 동기화와는 반대로 Response가 올때까지 대기했다가 완료 후 다음 진행 단계를 수행한다. (OS의 비선점 방식)
    ```

  - Vue 생명주기

  - ```markdown
    - create
    - mount
    - update
    - destory
    ```

  - get VS post 방식

  - ```markdown
    1. get 방식 : ? 뒤에 value가 생긴다. select 성향이 크다. 전송할 수 있는 데이터의 크기가 제한적이다. 보안X,    같은 요청시 caching된 데이터를 가져옴
    2. post 방식 : form 데이터로 전달한다. 서버 값이나 상태를 바꾸기 위해 사용한다.
    ```

  - 

- Python

  - compile 순서

    ```markdown
    1. 컴파일러가 .pyc 파일 생성 (bytecode)
    2. 인터프리터(vm)이 읽고 실행
    ```

  - 

- Language All

  - C vs java

    ```markdown
    1. C
       1) 절차 지향 언어 - 데이터를 중심으로
       2) 메모리 관리를 직접 해줘야한다.
       
    2. Java
       1) 객체 지향 언어 - 기능을 중심으로
       2) GC가 생김
    ```

  - 

- Etc

  - 빅데이터 3가지 요소 

    ```markdown
    - 3V(Volume, Velocity, Variety)
       1. Volume (크기) : 수십테라 혹은 수십 페타바이트 이상이다.
       2. Velocity (속도) : 대용량의 데이터를 빠르게 처리하고 분석할 수 있는 속성이다.
       3. Variety (다양성) : 정형, 비정형, 반정형 등의 다양한 종류의 데이터이다.
    
    - (추가) 5V(Value, Veracity)
       4. Value(가치)
       5. Veracity(정확성)
    ```

  - framework

    ```markdown
    기본적인 SW의 구조를 구현하고, 프로그래밍에 필요한 라이브러리를 포함하고 있는 반제품 형태의 SW이다.
    ```

  - DB 정규화

    ```markdown
    1. 1차 정규화
       - 엔티티에서 하나의 속성이 복수개의 값을 갖도록 설계되어 있을 때 하나의 속성이 단일 값(atomic value)을 갖도록    설계를 변경하는 과정
       
    2. 2차 정규화
       - 주식별자가 아닌 속성들 중에서 주식별자 전체가 아닌 일부 속성에 종속된 속성을 찾아 제거하는 과정
    
    3. 3차 정규화
       - 주식별자가 아닌 속성들 중에서 종속관계에 있는 속성을 찾아 제거하는 과정
    
    4. 역정규화
       - 시스템의 퍼포먼스를 향상시키기 위해 정규화 정책에 위배되는 행위
    ```

  - DB 슈퍼키 VS 기본키 VS 외래키 VS 후보키

    ```markdown
    1. 슈퍼 키
       레코드들을 식별할 수 있는 ‘필드의 집합’ (유일성) 테이블은 적어도 1개의 슈퍼키를 가져야 한다.
    
    2. 기본 키
       설계자가 여러 후보키 중 하나를 선택하여 정의한 식별자 (유일성, 최소성) 기본키의 모든 필드의 값은 null 이 될 수    없다.
    
    2. 외래 키
       다른 테이블의 기본키를 참조한다. 외래키의 모든 필드는 참조하는 기본키와 동일한 도메인(값의 종류&범위)을 갖는다.
       외래키의 모든 필드의 값은 참조하는 기본키와 동일하거나 null 이다.
    
    3. 후보 키
       슈퍼키에서 레코드를 식별할 수 있는 최소한의 필드만 남겨놓은 집합 (유일성, 최소성)
    ```

  - 명시적 형변환 VS 묵시적 형변환

    ```markdown
    1. 묵시적 형변환
       묵시적 형변환이기 때문에 java에서 자체적으로 형변환해준다.
    2. 명시적 형변환
       데이터 앞에 형변환 데이터 타입을 적어준다. 데이터가 큰 경우 묵시적 형변환시 데이터 손실이 생길 수 있어 에러가 발      생한다.
    ```

  - web VS hybrid VS native

  - ```markdown
    1. WEB
       장점 : 접근성이 좋다. (앱 설치 필요 X) 빠른 수정이 가능하다. 스마트폰의 용량을 차지하지 않는다. 개발 비용이 낮            다.
       단점 : 느리다. 기능적인 제한이 있다. 디자인 구현이 제한적이다. 오프라인 이용불가하다. 홈페이지와 겹칠 가능성 있             다.
    
    2. HYBRID
       장점 : 개발비용이 비교적 적다. 빠른 수정이 가능하다. 웹 퍼블리싱으로 확장이 가능하다.
       단점 : 수정시 애플, 구글의 승인이 필요하다.
    
    3. NATIVE
       장점 : 빠르다. 기기의 다양한 기능(카메라, 마이크등)을 사용할 수 있다.  푸시알람이 가능하다.
       단점 : 수정시 애플, 구글의 승인이 필수적으로 필요하다. 개발비용이 많다. 수정이 힘들다.
    ```

  - 웹 페이지 접속 순서

  - ```markdown
    
    ```

  - JSON vs XML

  - ```markdown
    1. JSON 과 XML의 공통점
       1) JSON과 XML 모두 "자체 설명"
       2) JSON과 XML 모두 "계층적"
       3) JSON과 XML 모두 많은 프로그래밍 언어에서 파싱하고 사용할 수 있습니다.
       4) JSON과 XML 모두 XMLHttpRequest를 사용하여 가져올 수 있습니다.
       
    2. JSON 과 XML의 차이점
       1) JSON은 종료 태그를 사용하지 않는다.
       2) JSON이 더욱 짧다.
       3) JSON은 읽고 쓰는 것이 빠르다.
       4) JSON은 배열을 사용할 수 있다.
       
    3. JSON 만의 가장 큰장점
       1) XML은 JSON보다 구문 분석하기가 훨씬 어렵다.
       2) JSON은 바로 사용할 수있는 JavaScript 객체로 파싱됩니다.
       3) AJAX 응용 프로그램의 경우 JSON은 XML보다 빠르고 쉽습니다.
    ```

  - Spring의 IoC 와 DI

  - ```markdown
    1. IoC (Inverse of Control)
       스프링은 IoC로 객체의 생성및 생명주기를 컨테이너가 도맡아서 하게 되었다.
       IoC로 부터 시작해 DI, AOP 등이 가능해 졌다.
       
    2. DI (Dependency Injection)
       객체간의 의존성을 자신이 아닌 외부에서 주입하는 것.
       소스 코드의 변경 없이 환경 설정만으로도 프로그램을 제어할 수 있는 방법이다. 
    
    3. AOP(Aspect Oriented Programming)
       어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것이다.
    
    ```

  - Container란?

  - ```markdown
    - 프로그램들이 작동하기위한 최소한의 요소들을 한 곳에 묶어 패키징한 OS. 작으면서 독립적으로 배포및 실행이 가능한 가상 머신이다.
    ```

  - 현대 IT&E의 사업

  - ```markdown
    - VR
    - 아마존과 협력한 무인 점포
    ```

  - 가상함수

  - ```markdown
    - overriding 할때 부모 클래스에 위치한 것.
    ```

  - Spring Boot 를 사용하는 이유?

  - ```markdown
    - 애플리케이션을 신속하게 설정하고, 스프링 구동 애플리케이션을 빌드하기위한 기본 구성을 제공하는 유틸리티입니다.
    - Spring 애플리케이션을 최대한 빨리 실행합니다. (겁나 좋음)
    - 작은 어플리케이션을 실행시키기 위해 WAS 설치 없이 embeded container에서 자신의 어플리케이션을 실행한다.
       (배포시 톰캣 연동없이 가능하기 때문에 간편하고 삽질할 일이 없다.)
    - xml 설정시 간단하다. (구조가 한눈에 보인다.)
    - 톰캣(Tomcat)이나 제티(Jetty)를 기본 내장할 수 있으며
       웹 프로젝트 띄우는 시간이 독립적인 톰캣으로 띄우는 시간보다 반은 단축된다(예를 들어 30초 -> 15초).
       또한 이렇게 서블릿 컨테이너가 내장될 수 있으므로 프로젝트를 .jar 파일 형태로 간단히 만들어 배포할 수 있다.
    - maven pom.xml에서 의존 라이브러리의 버전을 일일이 지정하지 않아도 된다. 스프링 부트가 권장 버전을 관리한다.
     
    ```

  - 싱글톤에 대해 설명 해주세요

  - ```markdown
    - 장점 : 고정된 메모리 영역을 사용하도록 단 한번 new 연산자로 인스턴스를 얻어오기때문에 메모리의 낭비를 줄입니다.
       전역변수로 선언되고 전역메서드로 호출 하기 때문에 다른 클래스에서 사용하기 쉽습니다.
       공통된 객체를 사용해야하는 코딩에서 매번 객체를 생성하지않고 같은 객체를 사용하도록 하면 성능면에서 훌륭해 진다.
    - 단점 : 단위 테스트에 불편하다. 멀티 쓰레드환경에서 동기화처리를 안하면 인스턴스가 두개가 생성된다.
    
    ```

    
    
